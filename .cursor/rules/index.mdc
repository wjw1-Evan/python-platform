---
alwaysApply: true
---

# 项目开发规范

## 项目架构

这是一个基于Django + MongoDB + React的微服务架构通用Admin平台。

### 技术栈

- **后端**: Python 3.10+, Django 4.2+, MongoEngine (MongoDB ODM), Django REST Framework, JWT认证, Django Channels (WebSocket)
- **数据库**: MongoDB 7.0
- **缓存**: Redis 7
- **前端**: React 19, Ant Design 5, Ant Design Pro, UmiJS Max
- **容器化**: Docker + Docker Compose
- **架构**: 微服务架构（6个服务 + API网关）

### 服务结构

- **API网关** (8000): 统一路由和认证
- **用户服务** (8001): 用户管理
- **企业服务** (8002): 企业管理
- **认证服务** (8003): JWT认证和登录注册
- **权限服务** (8004): 角色权限管理
- **通知服务** (8005): 消息通知和WebSocket
- **日志服务** (8006): 操作日志记录

## 代码规范

### 后端开发规范

1. **模型开发**
   - 所有模型必须继承 `BaseModel` (位于 `backend/common/data_factory/base_model.py`)
   - 使用 `BaseCRUD` 进行数据操作 (位于 `backend/common/data_factory/crud.py`)
   - 所有模型自动包含：`id`, `company_id`, `created_at`, `updated_at`, `is_deleted`, `created_by`, `updated_by`

2. **服务开发**
   - 每个微服务都是独立的Django项目
   - 服务目录结构：`services/{service_name}/`
   - 应用目录结构：`{service_name}/{app_name}/`
   - 必须配置多租户中间件实现数据隔离

3. **API开发**
   - 使用Django REST Framework
   - 所有API需要JWT认证（除登录注册外）
   - 使用序列化器（Serializers）进行数据验证
   - API路径格式：`/api/{resource}/`

4. **数据隔离**
   - 所有查询必须通过 `company_id` 过滤
   - 使用 `TenantMiddleware` 自动注入 `company_id`
   - `TenantMiddleware` 工作流程：
     1. 从JWT Token中提取 `user_id`
     2. 调用 `get_user_company_id(user_id)` 从数据库的 `UserCompany` 表查询
     3. 返回用户第一个激活且未删除的企业ID（`is_active=True`, `is_deleted=False`）
     4. 将 `company_id` 和 `user_id` 注入到 `request` 对象
   - 在视图中通过 `request.company_id` 和 `request.user_id` 访问
   - 如果用户没有关联企业，`request.company_id` 为 `None`
   - CRUD操作必须包含 `company_id` 参数

5. **JWT认证**
   - 使用 `djangorestframework-simplejwt`
   - Token存储在请求头：`Authorization: Bearer <token>`
   - **重要**: Token中只包含 `user_id`，不包含 `company_id`
   - `company_id` 从数据库的 `UserCompany` 表中实时读取（返回用户第一个激活的企业）
   - 使用 `common/utils/jwt_utils.py` 中的工具函数：
     - `generate_token(user_id)`: 生成Token（只包含user_id）
     - `get_user_from_token(token)`: 从Token提取user_id
     - `get_user_company_id(user_id)`: 从数据库获取用户的company_id
   - `TenantMiddleware` 自动从数据库读取 `company_id` 并注入到请求中
   - 优势：用户切换企业时无需重新登录，company_id始终从数据库获取最新值

### 前端开发规范

1. **技术栈**
   - React 19 + TypeScript
   - Ant Design 5 + Ant Design Pro
   - UmiJS Max 作为框架
   - 使用 `@umijs/max` 的 `request` 进行API调用

2. **目录结构**
   - `src/pages/`: 页面组件
   - `src/services/`: API服务定义
   - `src/components/`: 公共组件
   - `src/utils/`: 工具函数

3. **API调用**
   - 所有API调用使用 `src/services/api.ts` 中定义的方法
   - API基础路径：`/api`
   - 自动处理JWT Token（通过request拦截器）

4. **页面开发**
   - 使用Ant Design Pro的ProComponents
   - 遵循Ant Design设计规范
   - 使用TypeScript进行类型定义

## 开发流程

### 创建新模型

1. 在对应服务的应用目录创建 `models.py`（如果不存在）
2. 继承 `BaseModel`
3. 定义字段
4. 使用 `BaseCRUD` 进行数据操作

示例：
```python
from common.data_factory.base_model import BaseModel
from django.db import models

class MyModel(BaseModel):
    name = models.CharField(max_length=100)
    
    class Meta:
        db_table = 'my_models'
```

### 创建新服务

1. 在 `backend/services/` 下创建服务目录
2. 创建Django项目：`django-admin startproject {service_name}`
3. 创建应用：`python manage.py startapp {app_name}`
4. 配置 `settings.py`：
   - 添加 `common` 到 `INSTALLED_APPS`
   - 配置MongoDB连接
   - 配置JWT认证
   - 添加多租户中间件：`'common.middleware.tenant_middleware.TenantMiddleware'`
   - 中间件顺序：`TenantMiddleware` 应该在认证中间件之前
5. 在 `docker-compose.yml` 中添加服务配置

### 前端页面开发

1. 在 `frontend/src/pages/` 下创建页面目录
2. 在 `frontend/src/services/api.ts` 中添加API方法
3. 在路由配置中添加页面路由
4. 使用ProComponents快速开发

### 处理用户无企业的情况

在视图中需要检查用户是否有关联企业：

```python
@api_view(['GET'])
def my_view(request):
    company_id = getattr(request, 'company_id', None)
    user_id = getattr(request, 'user_id', None)
    
    if not company_id:
        return Response(
            {'error': '用户未关联企业，请先加入企业'},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    # 继续处理业务逻辑
    # ...
```

## 数据库操作

### 使用BaseCRUD

```python
from common.data_factory.crud import BaseCRUD
from .models import MyModel

crud = BaseCRUD(MyModel)

# 创建
instance = crud.create(data, company_id, created_by=user_id)

# 查询
instance = crud.get(id, company_id)
result = crud.list(company_id, filters={}, page=1, page_size=20)

# 更新
instance = crud.update(id, data, company_id, updated_by=user_id)

# 删除（软删除）
crud.delete(id, company_id)
```

### 在视图中获取company_id

```python
from rest_framework.decorators import api_view
from rest_framework.response import Response

@api_view(['GET'])
def my_view(request):
    # 从request对象获取company_id和user_id（由TenantMiddleware注入）
    company_id = getattr(request, 'company_id', None)
    user_id = getattr(request, 'user_id', None)
    
    if not company_id:
        return Response({'error': '用户未关联企业'}, status=400)
    
    # 使用company_id进行数据操作
    # ...
```

### 手动获取用户的company_id

```python
from common.utils.jwt_utils import get_user_company_id

# 获取用户的company_id（返回第一个激活的企业）
company_id = get_user_company_id(user_id)
if not company_id:
    # 用户没有关联企业
    pass
```

### JWT Token生成和使用

```python
from common.utils.jwt_utils import generate_token, get_user_from_token, get_user_company_id

# 生成Token（只包含user_id，不包含company_id）
tokens = generate_token(user_id)
access_token = tokens['access']
refresh_token = tokens['refresh']

# 从Token提取user_id
user_info = get_user_from_token(access_token)
user_id = user_info['user_id'] if user_info else None

# 注意：company_id需要从数据库读取，不能从Token获取
company_id = get_user_company_id(user_id)
```

### JWT Token生成和使用

```python
from common.utils.jwt_utils import generate_token, get_user_from_token

# 生成Token（只包含user_id）
tokens = generate_token(user_id)
access_token = tokens['access']
refresh_token = tokens['refresh']

# 从Token提取user_id
user_info = get_user_from_token(access_token)
user_id = user_info['user_id'] if user_info else None

# 注意：company_id需要从数据库读取，不能从Token获取
from common.utils.jwt_utils import get_user_company_id
company_id = get_user_company_id(user_id)
```

## 注意事项

1. **数据隔离**: 所有数据操作必须包含 `company_id`，确保多租户数据隔离
2. **company_id获取**: 
   - 优先使用 `request.company_id`（由TenantMiddleware自动注入）
   - 如果需要在非视图函数中获取，使用 `get_user_company_id(user_id)`
   - 始终检查 `company_id` 是否为 `None`，处理用户未关联企业的情况
3. **软删除**: 使用 `is_deleted` 标记删除，不进行物理删除
4. **JWT Token**: 
   - Token中只包含 `user_id`，不包含 `company_id`
   - 前端需要处理Token刷新逻辑
   - 刷新Token时只传递 `refresh` token，新的 `access` token会自动包含 `user_id`
5. **WebSocket**: 通知服务使用Django Channels实现实时推送，WebSocket连接时也会从数据库读取 `company_id`
6. **日志记录**: 日志服务中间件自动记录API请求
7. **Docker开发**: 使用 `docker-compose up` 启动所有服务
8. **前端代理**: 开发环境前端通过代理访问后端API（配置在 `config/proxy.ts`）
9. **多企业支持**: 用户可能关联多个企业，`get_user_company_id()` 返回第一个激活的企业。如需支持企业切换，需要额外的API和前端逻辑

## 文件命名规范

- Python文件：使用小写字母和下划线，如 `user_service.py`
- 模型类：使用大驼峰，如 `UserModel`
- API视图：使用大驼峰，如 `UserListView`
- 前端组件：使用大驼峰，如 `UserList.tsx`
- 前端文件：使用小驼峰，如 `api.ts`

## 提交规范

- 提交信息使用中文
- 格式：`类型: 简短描述`
- 类型：`feat`(新功能), `fix`(修复), `docs`(文档), `style`(格式), `refactor`(重构), `test`(测试), `chore`(构建)
